        -:    0:Source:C:/Users/Lenovo/Desktop/lab3/2021111045-lab1/code/src/graph.cpp
        -:    0:Graph:..\..\src\graph.gcno
        -:    0:Data:..\..\src\graph.gcda
        -:    0:Runs:1
        -:    1:#include "graph.h"
        -:    2:
        -:    3:#include <limits.h>
        -:    4:
        -:    5:#include <algorithm>
        -:    6:#include <cstdlib>
        -:    7:#include <ctime>
        -:    8:#include <fstream>
        -:    9:#include <iostream>
        -:   10:#include <sstream>
        -:   11:
        -:   12:#include "readFile.h"
        -:   13:using std::cout;
        -:   14:using std::endl;
        -:   15:// 构造函数
        9:   16:Graph::Graph(string str, map<string, int> _map1, map<int, string> _map2) {
        9:   17:    len = 0;
        9:   18:    map1 = _map1;
        9:   19:    map2 = _map2;
        9:   20:    std::stringstream STR(str);
        9:   21:    string word;
      567:   22:    while (STR >> word) {
      558:   23:        this->str[len++] = map1[word];
        -:   24:    }
        9:   25:    this->size = map1.size();
        9:   26:    initGraph();
        9:   27:}
        -:   28:
    #####:   29:void Graph::showStr() {
    #####:   30:    for (int i = 0; i < len; i++) {
    #####:   31:        cout << this->str[i] << " ";
        -:   32:    }
    #####:   33:    cout << endl;
    #####:   34:}
    #####:   35:void Graph::showGraph() {
    #####:   36:    for (int i = 0; i < this->size; i++) {
    #####:   37:        for (int j = 0; j < this->size; j++) {
    #####:   38:            cout << this->graph[i][j] << " ";
        -:   39:        }
    #####:   40:        cout << endl;
        -:   41:    }
    #####:   42:}
        -:   43:
        9:   44:void Graph::storeGraph() {
        -:   45:    std::ofstream file(
        9:   46:        "./graph.txt");  // 替换为你的文件名
        -:   47:
        9:   48:    if (!file.is_open()) {
    #####:   49:        std::cerr << "Unable to open file!" << std::endl;
    #####:   50:        return;  // 文件打开失败
        -:   51:    }
        -:   52:
        -:   53:    // 写入节点个数
        9:   54:    file << size << std::endl;
        -:   55:    // 写入图
      414:   56:    for (int i = 0; i < size; i++) {
    18630:   57:        for (int j = 0; j < size; j++) {
    18225:   58:            file << graph[i][j] << " ";
        -:   59:        }
      405:   60:        file << endl;
        -:   61:    }
        -:   62:    // 写入map2
      414:   63:    for (int i = 0; i < size; i++) {
      405:   64:        file << i << " " << map2[i] << endl;
        -:   65:    }
        -:   66:    // 关闭文件
        9:   67:    file.close();
        -:   68:
        9:   69:    return;
        9:   70:}
        -:   71:
       18:   72:void Graph::initGraph() {
      828:   73:    for (int i = 0; i < this->size; i++) {
    37260:   74:        for (int j = 0; j < this->size; j++) {
    36450:   75:            this->graph[i][j] = 0;
        -:   76:        }
        -:   77:    }
     1116:   78:    for (int i = 0; i < this->len - 1; i++) {
     1098:   79:        int index1 = this->str[i];
     1098:   80:        int index2 = this->str[i + 1];
     1098:   81:        this->graph[index1][index2] += 1;
        -:   82:    }
       18:   83:}
        -:   84:
        9:   85:Graph::~Graph() {}
        -:   86:
        9:   87:string Graph::queryBridgeWords(string word1, string word2) {
        9:   88:    int flag1 = 1;
        9:   89:    int flag2 = 1;
        9:   90:    if (map1.find(word1) == map1.end()) {
        2:   91:        flag1 = 0;
        -:   92:    }
        9:   93:    if (map1.find(word2) == map1.end()) {
        2:   94:        flag2 = 0;
        -:   95:    }
        9:   96:    string s = "";
        9:   97:    if (flag1 == 0 && flag2 == 0) {
        1:   98:        s = s + "No" + " '" + word1 + "' and '" + word2 + "' in the graph!";
        8:   99:    } else if (flag1 == 0) {
        1:  100:        s = s + "No" + " '" + word1 + "' in the graph!";
        7:  101:    } else if (flag2 == 0) {
        1:  102:        s = s + "No" + " '" + word2 + "' in the graph!";
        -:  103:    } else {
        -:  104:        // 存在word1与word2，查询图
        6:  105:        s = findMiddleWord(map1[word1], map1[word2], 1);
        -:  106:    }
        9:  107:    return s;
    =====:  108:}
        6:  109:string Graph::findMiddleWord(int firstword, int secondword, int choice) {
        6:  110:    string str = "";
        6:  111:    int flag = 0;
      276:  112:    for (int middleword = 0; middleword < size; middleword++) {
      270:  113:        if (graph[firstword][middleword] != 0) {
        9:  114:            if (graph[middleword][secondword] != 0) {
        3:  115:                flag = 1;
        3:  116:                str = str + map2[middleword] + ",";
        -:  117:            }
        -:  118:        }
        -:  119:    }
        6:  120:    switch (choice) {
    #####:  121:        case 0: {
    #####:  122:            if (flag == 0) {
    #####:  123:                str = str + "No bridge words from " + "\"" + map2[firstword] + " \"to \"" + map2[secondword] +
    #####:  124:                      "\"!";
        -:  125:            } else {
    #####:  126:                str[str.size() - 1] = '.';
    #####:  127:                string s = "";
    #####:  128:                str = s + "The bridge words from " + "\"" + map2[firstword] + " \"to \"" + map2[secondword] +
    #####:  129:                      "\" are:" + str;
    #####:  130:            }
    #####:  131:            break;
        -:  132:        }
        -:  133:        // 返回中间词或者空
        6:  134:        case 1: {
        6:  135:            if (flag == 0) {
        3:  136:                str = " ";
        -:  137:            } else {
        3:  138:                int count = 0;
       15:  139:                for (int i = 0; i < str.size(); i++) {
       12:  140:                    if (str[i] == ',') {
        3:  141:                        str[i] = ' ';
        3:  142:                        count++;
        -:  143:                    }
        -:  144:                }
        -:  145:                // 选择一个桥接词
        3:  146:                str = chooseOne(str, count);
        -:  147:            }
        6:  148:            break;
        -:  149:        }
        -:  150:    }
        6:  151:    return str;
    =====:  152:}
        3:  153:string Graph::chooseOne(string str, int len) {
        3:  154:    srand(static_cast<unsigned int>(time(nullptr)));
        3:  155:    int random_number = (rand()) % len;
        -:  156:    // 选择合适的一个桥接词
        3:  157:    std::stringstream STR(str);
        3:  158:    string word;
        6:  159:    for (int i = 0; i <= random_number; i++) {
        3:  160:        STR >> word;
        -:  161:    }
        3:  162:    return word;
        3:  163:}
        -:  164:
    #####:  165:string Graph::generateNewText(string inputText) {
        -:  166:    // 已经获得用户输入文本，对文本做处理
    #####:  167:    preHandleStr(inputText);
    #####:  168:    std::stringstream STR(inputText);
    #####:  169:    string word1;
    #####:  170:    string word2;
    #####:  171:    string str = "";
    #####:  172:    int step = 0;
        -:  173:    // 读取第一个存在word1
    #####:  174:    while (STR >> word1) {
    #####:  175:        str = str + word1 + ' ';
    #####:  176:        if (map1.find(word1) != map1.end()) {
    #####:  177:            break;
        -:  178:        }
        -:  179:    }
    #####:  180:    string temp_str;
    #####:  181:    while (STR >> word2) {
        -:  182:        // str+=word2;
    #####:  183:        if (map1.find(word2) == map1.end()) {
    #####:  184:            str = str + word2 + ' ';
    #####:  185:            step = 1;
    #####:  186:            continue;
        -:  187:        }
    #####:  188:        if (step != 0) {
    #####:  189:            str = str + word2 + ' ';
    #####:  190:            step = 0;
    #####:  191:            word1 = word2;
    #####:  192:            continue;
        -:  193:        }
    #####:  194:        temp_str = findMiddleWord(map1[word1], map1[word2], 1);
    #####:  195:        str = temp_str == " " ? str + word2 + ' ' : str + temp_str + ' ' + word2 + ' ';
    #####:  196:        word1 = word2;
        -:  197:    }
    #####:  198:    return str;
    #####:  199:}
        -:  200:
        -:  201:// 最短路径计算
    #####:  202:void Graph::calcShortestPath(string word1, string word2) {
    #####:  203:    string str = "";
    #####:  204:    vector<vector<int>> allpaths;
    #####:  205:    vector<int> path;
    #####:  206:    if (map1.find(word1) == map1.end() || (map1.find(word2) == map1.end() && !word2.empty())) {
    #####:  207:        if (!word2.empty()) {
    #####:  208:            str = str + "There is no word named " + word1 + " or " + word2;
    #####:  209:            cout << str << endl;
        -:  210:        } else {
    #####:  211:            str = str + "There is no word named " + word1;
    #####:  212:            cout << str << endl;
        -:  213:        }
    #####:  214:    } else if (word2.empty())  // 只输入了一个单词
        -:  215:    {
    #####:  216:        for (int j = 0; j < size; j++) {
    #####:  217:            if (j != map1[word1]) {
    #####:  218:                cout << "The shortest path form " << word1 << " to " << map2[j] << " : ";
    #####:  219:                path.clear();
    #####:  220:                allpaths.clear();
    #####:  221:                dijkstra(map1[word1], j, allpaths, path);
    #####:  222:                vector<vector<int>>::iterator iter;
    #####:  223:                if (allpaths.empty()) {
    #####:  224:                    str = "Do not have a path from " + word1 + " to " + map2[j];
    #####:  225:                    cout << str << endl;
        -:  226:                } else {
    #####:  227:                    for (iter = allpaths.begin(); iter != allpaths.end(); ++iter) {
    #####:  228:                        for (int i = 0; i < (*iter).size(); ++i) {
    #####:  229:                            cout << map2[(*iter)[i]];
    #####:  230:                            if (j != (*iter)[i]) {
    #####:  231:                                cout << " -> ";
        -:  232:                            }
        -:  233:                        }
    #####:  234:                        cout << endl;
        -:  235:                    }
        -:  236:                }
        -:  237:            }
        -:  238:        }
        -:  239:    } else {  // 输入了两个单词
    #####:  240:        dijkstra(map1[word1], map1[word2], allpaths, path);
    #####:  241:        cout << "The shortest path form " << word1 << " to " << word2 << " : ";
    #####:  242:        vector<vector<int>>::iterator iter;
    #####:  243:        if (allpaths.empty()) {
    #####:  244:            str = "Do not have a path from " + word1 + " to " + word2;
    #####:  245:            cout << str << endl;
        -:  246:        } else {
    #####:  247:            for (iter = allpaths.begin(); iter != allpaths.end(); ++iter) {
    #####:  248:                for (int i = 0; i < (*iter).size(); ++i) {
    #####:  249:                    cout << map2[(*iter)[i]];
    #####:  250:                    if (map1[word2] != (*iter)[i]) {
    #####:  251:                        cout << " -> ";
        -:  252:                    }
        -:  253:                }
    #####:  254:                cout << endl;
        -:  255:            }
        -:  256:        }
        -:  257:    }
    #####:  258:}
        -:  259:
    #####:  260:int Graph::minDistance(int dist[], int sptSet[]) {
        -:  261:    // 初始化最小距离为无穷大
    #####:  262:    int min = INT_MAX, min_index;
        -:  263:
    #####:  264:    for (int v = 0; v < size; v++)
    #####:  265:        if (sptSet[v] == 0 && dist[v] <= min) {
    #####:  266:            min = dist[v], min_index = v;
        -:  267:        }
    #####:  268:    return min_index;
        -:  269:}
        -:  270:
    #####:  271:void Graph::dijkstra(int src, int dest, vector<vector<int>>& allpaths, vector<int>& path) {
    #####:  272:    int dist[size - 1];  // dist[i]将保存从源点到顶点i的最短路径长度
    #####:  273:    int sptSet[size - 1];  // sptSet[i]为真，如果顶点i包含在最短路径树中或最短路径已被确定
    #####:  274:    vector<vector<int>> preNodes(size);
    #####:  275:    for (int i = 0; i <= size - 1; i++) {
    #####:  276:        if (graph[src][i] == 0) {
    #####:  277:            dist[i] = INT_MAX;
        -:  278:            // preNodes[i].push_back(-1);//www 下次不写递归了
        -:  279:        } else {
    #####:  280:            dist[i] = graph[src][i];
    #####:  281:            preNodes[i].push_back(src);
        -:  282:        }
    #####:  283:        sptSet[i] = 0;
        -:  284:    }
    #####:  285:    dist[src] = 0;
    #####:  286:    sptSet[src] = true;
        -:  287:
    #####:  288:    for (int count = 0; count <= size - 1; count++) {
    #####:  289:        int u = minDistance(dist, sptSet);
    #####:  290:        sptSet[u] = 1;
    #####:  291:        for (int v = 0; v < size; v++) {
    #####:  292:            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {
    #####:  293:                dist[v] = dist[u] + graph[u][v];
    #####:  294:                preNodes[v].clear();
    #####:  295:                preNodes[v].push_back(u);
    #####:  296:            } else if (!sptSet[v] && graph[u][v] && dist[u] + graph[u][v] == dist[v]) {
    #####:  297:                preNodes[v].push_back(u);
        -:  298:            }
        -:  299:        }
        -:  300:    }
        -:  301:    // 根据每个节点前驱节点得到从src到dest最短路径
    #####:  302:    findPaths(src, dest, preNodes, path, allpaths);
    #####:  303:}
        -:  304:
    #####:  305:void Graph::findPaths(int src, int dest, vector<vector<int>>& preNodes, vector<int>& path,
        -:  306:                      vector<vector<int>>& allpaths) {
    #####:  307:    path.push_back(dest);
    #####:  308:    if (dest == src) {
    #####:  309:        vector<int> temp = path;
    #####:  310:        reverse(temp.begin(), temp.end());
    #####:  311:        allpaths.push_back(temp);
    #####:  312:    } else {
    #####:  313:        for (int i = 0; i < preNodes[dest].size(); i++) {
    #####:  314:            findPaths(src, preNodes[dest][i], preNodes, path, allpaths);
        -:  315:        }
        -:  316:    }
    #####:  317:    path.pop_back();
    #####:  318:}
        -:  319:
        -:  320:// 随机游走
    #####:  321:string Graph::randomWalk() {
    #####:  322:    vector<int> path;
        -:  323:    // 随机选择一个节点遍历，如果对应边已经走过，则把i,j设置为true
    #####:  324:    srand(static_cast<unsigned int>(time(nullptr)));
    #####:  325:    int random_number = (rand()) % size;
    #####:  326:    cout << "random_number" << random_number << endl;
    #####:  327:    scan(path, random_number);
    #####:  328:    int _size = path.size();
    #####:  329:    string str = "";
    #####:  330:    for (int i = 0; i < _size; i++) {
    #####:  331:        str = str + map2[path[i]] + " ";
        -:  332:    }
    #####:  333:    return str;
    #####:  334:}
        -:  335:
        -:  336:// 随机游走
    #####:  337:void Graph::scan(vector<int>& path, int src) {
    #####:  338:    bool temp[size][size] = {{0}};
    #####:  339:    string str = "";
    #####:  340:    int count = 0;
    #####:  341:    path.push_back(src);
        -:  342:    while (true) {
    #####:  343:        str = "";
    #####:  344:        count = 0;
        -:  345:        // 随机游走
    #####:  346:        for (int i = 0; i < size; i++) {
    #####:  347:            if (graph[src][i] != 0) {
    #####:  348:                str = str + map2[i] + " ";
    #####:  349:                count++;
        -:  350:            }
        -:  351:        }
    #####:  352:        if (count != 0) {
    #####:  353:            str = chooseOne(str, count);
    #####:  354:            if (temp[src][map1[str]]) {
    #####:  355:                src = map1[str];
    #####:  356:                path.push_back(src);
    #####:  357:                break;
        -:  358:            } else {
    #####:  359:                temp[src][map1[str]] = true;
    #####:  360:                src = map1[str];
    #####:  361:                path.push_back(src);
        -:  362:            }
        -:  363:        } else {
    #####:  364:            break;
        -:  365:        }
    #####:  366:    }
    #####:  367:}
